const functions = require('firebase-functions');
const admin = require('firebase-admin');
const crypto = require('crypto');

/**
 * Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ØªØ´ÙÙŠØ± Ø§Ù„Ù€ PIN ÙˆÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± (SHA-256)
 */
function hashData(data) {
    return crypto.createHash('sha256').update(data).digest('hex');
}

exports.createNewUserAccount = functions.https.onCall(async (data, context) => {
    const { 
        fullName, 
        phoneNumber, 
        password, 
        pin, 
        userType, // 'USER' (Ø§ÙØªØ±Ø§Ø¶ÙŠ) Ø£Ùˆ 'MERCHANT'
        deviceInfo // Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ´ØºÙŠÙ„ØŒ Ù†ÙˆØ¹ Ø§Ù„Ø¬Ù‡Ø§Ø²
    } = data;
    
    const db = admin.database();
    const userIP = context.rawRequest.headers['x-forwarded-for'] || context.rawRequest.connection.remoteAddress;

    // 1. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø·ÙˆÙ„ Ø§Ù„Ù€ PIN (6 Ø£Ø±Ù‚Ø§Ù…)
    if (!/^\d{6}$/.test(pin)) {
        throw new functions.https.HttpsError('invalid-argument', 'ÙŠØ¬Ø¨ Ø£Ù† ÙŠØªÙƒÙˆÙ† Ø±Ù…Ø² PIN Ù…Ù† 6 Ø£Ø±Ù‚Ø§Ù…');
    }

    try {
        // 2. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ù… ØªÙƒØ±Ø§Ø± Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ
        const phoneSnap = await db.ref(`registered_phones/${phoneNumber}`).once('value');
        if (phoneSnap.exists()) {
            throw new functions.https.HttpsError('already-exists', 'Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ Ù‡Ø°Ø§ Ù…Ø³Ø¬Ù„ Ù…Ø³Ø¨Ù‚Ø§Ù‹');
        }

        if (!context.auth) throw new functions.https.HttpsError('unauthenticated', 'ÙŠØ¬Ø¨ Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„ØªØ­Ù‚Ù‚');
        const uid = context.auth.uid;

        // 3. Ø¨Ù†Ø§Ø¡ Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø´Ø§Ù…Ù„
        const userData = {
            profile: {
                fullName: fullName,
                phoneNumber: phoneNumber,
                password: hashData(password), // ØªØ´ÙÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
                pin: hashData(pin), // ØªØ´ÙÙŠØ± Ø§Ù„Ù€ PIN
                userType: userType || "USER", // Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ Ù…Ø³ØªØ®Ø¯Ù…
                verificationStatus: "UNVERIFIED", // Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ ØºÙŠØ± Ù…ÙˆØ«Ù‚
                idCardUrl: "", // Ø³ÙŠØªÙ… Ù…Ù„Ø¤Ù‡ Ø¨Ø±Ø§Ø¨Ø· Ø§Ù„ØµÙˆØ±Ø© Ø¹Ù†Ø¯ Ø§Ù„Ø±ÙØ¹ Ù„Ø§Ø­Ù‚Ø§Ù‹
                isFrozen: false, // Ø¥Ø¶Ø§ÙØ© Ø­Ø§Ù„Ø© ØªØ¬Ù…ÙŠØ¯ Ø§Ù„Ø­Ø³Ø§Ø¨ (Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ Ù†Ø´Ø·)
                createdAt: admin.database.ServerValue.TIMESTAMP,
                lastPasswordChange: admin.database.ServerValue.TIMESTAMP,
                lastPinChange: admin.database.ServerValue.TIMESTAMP
            },
            wallets: {
                lyd_balance: 0.0,
                egp_balance: 0.0,
                egp_pending_balance: 0.0 // Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù…ØµØ±ÙŠ Ø§Ù„Ù…Ø¹Ù„Ù‚ (ØµÙØ±)
            },
            security: {
                activeDevice: deviceInfo || "Unknown",
                operatingSystem: context.rawRequest.headers['user-agent'] || "Unknown",
                lastIpAddress: userIP
            },
            history: {
                lyd_transactions: {}, // Ø³Ø¬Ù„ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù„Ù„ÙŠØ¨ÙŠØ©
                egp_transfers: {}     // Ø³Ø¬Ù„ Ø§Ù„ØªØ­ÙˆÙŠÙ„Ø§Øª Ø§Ù„Ù…ØµØ±ÙŠØ©
            }
        };

        const batch = {};
        batch[`users/${uid}`] = userData;
        batch[`registered_phones/${phoneNumber}`] = uid;

        await db.ref().update(batch);

        // 4. Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø± Ù„Ø±ÙØ¹ Ø§Ù„Ù‡ÙˆÙŠØ©
        const payload = {
            notification: {
                title: "Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ ØªØ·Ø¨ÙŠÙ‚Ù†Ø§! ğŸ‰",
                body: "ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨Ùƒ Ø¨Ù†Ø¬Ø§Ø­. ÙŠØ±Ø¬Ù‰ Ø±ÙØ¹ ØµÙˆØ±Ø© Ø§Ù„Ù‡ÙˆÙŠØ© Ù„ØªÙˆØ«ÙŠÙ‚ Ø­Ø³Ø§Ø¨Ùƒ Ù„Ù„Ø¨Ø¯Ø¡ ÙÙŠ Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙƒØ§ÙØ© Ø§Ù„Ù…ÙŠØ²Ø§Øª."
            },
            data: {
                action: "UPLOAD_ID_IMAGE",
                status: "UNVERIFIED"
            }
        };

        const fcmTokenSnap = await db.ref(`users/${uid}/fcmToken`).once('value');
        if (fcmTokenSnap.exists()) {
            await admin.messaging().sendToDevice(fcmTokenSnap.val(), payload);
        }

        return { 
            success: true, 
            message: "ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø³Ø§Ø¨ Ø¨Ù†Ø¬Ø§Ø­ØŒ ÙŠØ±Ø¬Ù‰ Ø±ÙØ¹ ÙˆØ«Ø§Ø¦Ù‚ Ø§Ù„ØªÙˆØ«ÙŠÙ‚" 
        };

    } catch (error) {
        throw new functions.https.HttpsError('internal', error.message);
    }
});
